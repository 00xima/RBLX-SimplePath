{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>SimplePath is an open-source pathfinding module that gives you the ability to quickly create a pathfinding script for humanoids and non-humanoids with just a few lines of code. Pathfinding is done using Roblox's PathfindingService.</p> <p>This module works by using a \"repetitive\" approach to pathfinding. The pathfinding agent moves a more efficient path when computed repetitively instead of just once. Part of the reason why is because computing the path once doesn't guarantee that the agent reaches the goal as expected. Taking the repetitive approach accounts for any obstructions or obstacles blocking the path at the current time. This guarantees that the agent will reach its goal no matter what as long as it's traversable within the scope of PathfindingService. Although you can still use SimplePath normally, it is strongly suggested that you take a repetitive approach to pathfinding as this was the primary concept kept in mind during the development of this module. However, in some scenarios, it might be better to compute the path just once. For example, if the agent does not interact with moving objects, you should consider changing the structure of your pathfinding code by reducing the number of repetitions between path computations to improve performance.</p> <p>To get started with using SimplePath visit Getting Started.</p> <p></p> <p>Installation:</p> <p>Get the SimplePath modulescript from Roblox or get the latest release from GitHub.</p> <p></p> <p>Links:</p> <ul> <li>GitHub</li> <li>DevForum</li> <li>Roblox</li> <li>Discord</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#configuration","title":"Configuration","text":"<p>The settings below are default values that can be accessed directly from the SimplePath modulescript.</p> <p>Note</p> <p>Changing default settings will only affect agents that don't already have overridden settings.</p> <p>To override settings for a single agent, pass in a dictionary (with a setting as the key) to the constructor and include values in the dictionary to override. See constructor for more info.</p> <p></p>"},{"location":"api-reference/#time_variance","title":"TIME_VARIANCE","text":"<p><code>Settings.TIME_VARIANCE: number</code> [default: 0.07]</p> <p>Represents the minimum time in seconds elapsed between Path.Run calls. The default setting is roughly 14 computations per second. This is necessary to allow the agent the freedom for movement (give the agent some time to reach the next waypoint before computing a new path).</p> <p></p>"},{"location":"api-reference/#comparison_checks","title":"COMPARISON_CHECKS","text":"<p><code>Settings.COMPARISON_CHECKS: number</code> [default: 1]</p> <p>During pathfinding, in the case where the agent is stationary at the same position for 1 + COMPARISON_CHECKS consecutive Path.Run calls, the agent attempts to avoid the obstruction by jumping. This is necessary in order to prevent the agent from being at rest for infinity (unless otherwise moved by an external object).</p> <p></p>"},{"location":"api-reference/#jump_when_stuck","title":"JUMP_WHEN_STUCK","text":"<p><code>Settings.JUMP_WHEN_STUCK: boolean</code> [default: true] [humanoid only]</p> <p><code>Settings.JUMP_WHEN_STUCK</code> is directly dependant on <code>Settings.COMPARISON_CHECKS</code>. If this is false, the agent will not attempt to jump.</p> <p>Warning</p> <p>Overriding this setting to <code>false</code> will prevent the agent from jumping which can cause the agent to remain at rest for infinity. Do not disable this setting without properly handling it using ErrorType.AgentStuck.</p>"},{"location":"api-reference/#errortypes","title":"ErrorTypes","text":"Example<pre><code>Path.Error:Connect(function(errorType)\n    if errorType == SimplePath.ErrorType.ComputationError then\n        --code (1)\n    end\nend)\n</code></pre> <ol> <li>This code block will run whenever there's a ComputationError.</li> </ol> <p>Info</p> <p>Use ErrorTypes to determine the type of error received from the Path.Error event. For additional debug options, see Path.LastError.</p> <p></p>"},{"location":"api-reference/#limitreached","title":"LimitReached","text":"<p><code>ErrorType.LimitReached: ErrorType and string</code></p> <p>The elapsed time between Path.Run calls is less than Settings.TIME_VARIANCE. For stability purposes, this error is invoked after <code>Path:Run()</code> yields for Settings.TIME_VARIANCE.</p> <p>It is recommended to avoid depending on this ErrorType.</p> <p></p>"},{"location":"api-reference/#targetunreachable","title":"TargetUnreachable","text":"<p><code>ErrorType.TargetUnreachable: ErrorType and string</code></p> <p>Target is unreachable.</p> <p></p>"},{"location":"api-reference/#computationerror","title":"ComputationError","text":"<p><code>ErrorType.ComputationError: ErrorType and string</code></p> <p>Path computation failed.</p> <p></p>"},{"location":"api-reference/#agentstuck","title":"AgentStuck","text":"<p><code>ErrorType.AgentStuck: ErrorType and string</code></p> <p>Agent is stuck (possibly due to an obstruction of some kind).</p> <p>Note</p> <p>This is different from Path.Blocked in the sense that it is detected by SimplePath itself when the agent does not move for Settings.COMPARISON_CHECKS + 1 consecutive Path.Run calls.</p>"},{"location":"api-reference/#statustypes","title":"StatusTypes","text":"<p>Read the Path.Status property to get the current Path status.</p> <p></p>"},{"location":"api-reference/#idle","title":"Idle","text":"<p><code>StatusType.Idle: StatusType and string</code></p> <p>Path is in idle state.</p> <p></p>"},{"location":"api-reference/#active","title":"Active","text":"<p><code>StatusType.Active: StatusType and string</code></p> <p>Path is in active state.</p>"},{"location":"api-reference/#static-methods","title":"Static Methods","text":""},{"location":"api-reference/#getnearestcharacter","title":"GetNearestCharacter","text":"<p><code>&lt;model or nil&gt; SimplePath.GetNearestCharacter(fromPosition: Vector3)</code> </p> <p>Returns a <code>model</code> of the nearest character from the provided <code>Vector3</code> position or <code>nil</code> if no character is found.</p>"},{"location":"api-reference/#path","title":"Path","text":""},{"location":"api-reference/#constructor","title":"Constructor","text":"<p><code>&lt;Path&gt; SimplePath.new(agent: model, agentParameters: Dictionary or nil, override: Dictionary or nil)</code></p> <p>Creates a new Path object using the <code>agent</code> with optional <code>agentParameters</code>. Pass in <code>override</code> as a dictionary that includes a setting and its overridden value.</p> <p>Note</p> <p><code>SimplePath.new()</code> is a constructor that creates a new Path and it should only be created once per agent. You can call <code>Path:Run()</code> on the same Path object multiple times without having to create a new Path every time you need to do pathfinding.</p> <p>Info</p> <p>Use agent parameters for custom characters to compute the best path. Find out more about agent parameters and how to use them at Roblox Developer Hub.</p> <p>Refine the path computation further by using pathfinding modifiers. To use this feature with SimplePath, Simply include modifier data in <code>agentParameters</code> normally. Find out more about pathfinding modifiers at Roblox Developer Hub.</p>"},{"location":"api-reference/#properties","title":"Properties","text":""},{"location":"api-reference/#visualize","title":"Visualize","text":"<p><code>Path.Visualize: boolean</code> [default: false]</p> <p>Set this property to <code>true</code> before the first <code>Path:Run()</code> to visualize waypoints.</p> <p></p>"},{"location":"api-reference/#status","title":"Status","text":"<p><code>Path.Status: SimplePath.StatusType</code> [readonly]</p> <p>Returns the current StatusType of Path.</p> <p>Note</p> <p>This will return <code>SimplePath.StatusType.Idle</code> always for non-humanoids since pathfinding for a non-humanoid is meant to be handled manually.</p> <p></p>"},{"location":"api-reference/#lasterror","title":"LastError","text":"<p><code>Path.LastError: SimplePath.ErrorType</code> [readonly]</p> <p>Returns the last ErrorType.</p>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#run","title":"Run","text":"<p><code>&lt;boolean&gt; Path:Run(target: Vector3 or BasePart)</code></p> <p>This method returns <code>true</code> if the computation was successful. If it returns <code>false</code>, the Path.Error event is fired with a ComputationError. This method automatically yields if the elapsed time between consecutive calls is less than Settings.TIME_VARIANCE.</p> <p></p>"},{"location":"api-reference/#stop","title":"Stop","text":"<p><code>&lt;void&gt; Path:Stop()</code></p> <p>Stops the navigation of the current Path if Path.Status is in an active state and fires the Path.Stopped event.</p> <p>Note</p> <p>This method cannot be used for non-humanoids since pathfinding is meant to be handled manually.</p> <p></p>"},{"location":"api-reference/#destroy","title":"Destroy","text":"<p><code>&lt;void&gt; Path:Destroy()</code></p> <p>Destroy Path.</p>"},{"location":"api-reference/#events","title":"Events","text":""},{"location":"api-reference/#reached","title":"Reached","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Reached(agent: model, finalWaypoint: PathWaypoint)</code></p> <p>This event is fired after the <code>agent</code> reaches its target and returns the final <code>PathWaypoint</code>.</p> <p>Info</p> <p>Find out more about <code>PathWaypoint</code> at Roblox Developer Hub.</p> <p></p>"},{"location":"api-reference/#waypointreached","title":"WaypointReached","text":"<p><code>&lt;RBXScriptSignal&gt; Path.WaypointReached(agent: model, last: PathWaypoint, next: PathWaypoint)</code></p> <p>This event is fired every time the next <code>PathWaypoint</code> is reached.</p> <p>Note</p> <p>Make use of this event when pathfinding for non-humanoids.</p> <p>Warning</p> <p>For stabililty purposes, this event will not fire for the second-last waypoint when used for Humanoids.</p> <p></p>"},{"location":"api-reference/#blocked","title":"Blocked","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Blocked(agent: model, blocked: PathWaypoint)</code></p> <p><code>blocked</code> is a <code>PathWaypoint</code> such that: <code>currentWaypoint.Index &lt;= blocked.Index &lt;= currentWaypoint.Index + 1</code>.</p> <p></p>"},{"location":"api-reference/#error","title":"Error","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Error(error: ErrorType and string)</code></p> <p>Fires when an error from any of the ErrorTypes occurs.</p> <p></p>"},{"location":"api-reference/#stopped","title":"Stopped","text":"<p><code>&lt;RBXScriptSignal&gt; Path.Stopped(agent: model)</code></p> <p>Fires after <code>Path:Stop()</code> is called.</p> <p>Note</p> <p>Just like the Path.Stop method, this event should only be used for humanoids.</p>"},{"location":"examples/humanoid/","title":"Humanoid Examples","text":"<p>The following examples is explained in detail here.</p> <p></p>"},{"location":"examples/humanoid/#using-events","title":"Using Events","text":"<pre><code>--Import the module so you can start using it\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\n--Define npc\nlocal Dummy = workspace.Dummy\n\n-- Define a part called \"Goal\"\nlocal Goal = workspace.Goal\n\n--Create a new Path using the Dummy\nlocal Path = SimplePath.new(Dummy)\n\n--Helps to visualize the path\nPath.Visualize = true\n\n--Compute a new path every time the Dummy reaches the goal part\nPath.Reached:Connect(function()\n    Path:Run(Goal)\nend)\n\n--Dummy knows to compute path again if something blocks the path\nPath.Blocked:Connect(function()\n    Path:Run(Goal)\nend)\n\n--If the position of Goal changes at the next waypoint, compute path again\nPath.WaypointReached:Connect(function()\n    Path:Run(Goal)\nend)\n\n--Dummmy knows to compute path again if an error occurs\nPath.Error:Connect(function(errorType)\n    Path:Run(Goal)\nend)\n\nPath:Run(Goal)\n</code></pre>"},{"location":"examples/humanoid/#using-loops","title":"Using Loops","text":"<pre><code>--Import the module so you can start using it\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\n--Define npc\nlocal Dummy = workspace.Dummy\n\n-- Define a part called \"Goal\"\nlocal Goal = workspace.Goal\n\n--Create a new Path using the Dummy\nlocal Path = SimplePath.new(Dummy)\n\n--Helps to visualize the path\nPath.Visualize = true\n\nwhile true do\n    Path:Run(Goal)\nend\n</code></pre>"},{"location":"examples/non-humanoid/","title":"Non-Humanoid Examples","text":"<p>Pathfinding for non-humanoid models can get a little complicated. Consider converting your non-humanoid model to a humanoid if possible.</p> <p></p>"},{"location":"examples/non-humanoid/#example-1","title":"Example 1","text":"<pre><code>local TweenService = game:GetService(\"TweenService\")\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\nlocal Model = workspace.Model\nlocal Goal = workspace.Goal\nlocal Path = SimplePath.new(Model)\n\nlocal function tween(part, destination)\n    local tweenBase = TweenService:Create(part, TweenInfo.new(0.07), {Position = destination + Vector3.new(0, 0.5, 0)})\n    tweenBase:Play()\n    tweenBase.Completed:Wait()\nend\n\nPath.Visualize = true\n\n--Tween model to final waypoint when reached\nPath.Reached:Connect(function(model, finalWaypoint)\n    tween(model.PrimaryPart, finalWaypoint.Position)\nend)\n\n--Call Path:Run() at the end of the event to indicate the end of movement for the current waypoint\nPath.WaypointReached:Connect(function(model, lastWaypoint, nextWaypoint)\n    tween(model.PrimaryPart, nextWaypoint.Position)\n    Path:Run()\nend)\n\nPath:Run(Goal)\n</code></pre>"},{"location":"examples/non-humanoid/#example-2","title":"Example 2","text":"<pre><code>local TweenService = game:GetService(\"TweenService\")\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\nlocal Model = workspace.Model\nlocal Goal = workspace.Goal\nlocal Path = SimplePath.new(Model)\n\nlocal function tween(part, destination)\n    local tweenBase = TweenService:Create(part, TweenInfo.new(0.07), {Position = destination + Vector3.new(0, 0.5, 0)})\n    tweenBase:Play()\n    tweenBase.Completed:Wait()\nend\n\nPath.Visualize = true\n\n--If the path is blocked\nPath.Blocked:Connect(function()\n    Path:Run(Goal)\nend)\n\n--In case of an error\nPath.Error:Connect(function()\n    Path:Run(Goal)\nend)\n\nPath.Reached:Connect(function(model, finalWaypoint)\n    tween(model.PrimaryPart, finalWaypoint.Position)\n    Path:Run(Goal)\nend)\n\nPath.WaypointReached:Connect(function(model, lastWaypoint, nextWaypoint)\n    tween(model.PrimaryPart, nextWaypoint.Position)\n    Path:Run(Goal)\nend)\n\nPath:Run(Goal)\n</code></pre>"},{"location":"examples/non-humanoid/#example-3","title":"Example 3","text":"<pre><code>local TweenService = game:GetService(\"TweenService\")\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\nlocal Model = workspace.Model\nlocal Goal = workspace.Goal\nlocal Path = SimplePath.new(Model)\n\nPath.Visualize = true\n\nPath.Reached:Connect(function(model, finalWaypoint)\n    model.PrimaryPart.Position = finalWaypoint.Position + Vector3.new(0, 0.5, 1)\nend)\n\nPath.WaypointReached:Connect(function(model, lastWaypoint, nextWaypoint)\n    model.PrimaryPart.Position = nextWaypoint.Position + Vector3.new(0, 0.5, 1)\nend)\n\nwhile true do\n    Path:Run(Goal)\n    task.wait()\nend\n</code></pre>"},{"location":"guides/getting-started/","title":"Getting Started","text":"<p>This tutorial shows you how you can set up SimplePath and teaches you a basic implementation of the module.</p>"},{"location":"guides/getting-started/#installation","title":"Installation","text":"<p>Get the module from the Roblox library or get the latest release from GitHub.</p> <p>Note</p> <p>For the purposes of the tutorial, the script assumes the modulescript is in <code>game.ServerStorage</code>.</p> <p>After you insert the module to your place, add a new script to <code>game.ServerScriptService</code> and paste the folowing code to start using the module:</p> <pre><code>--Import the module so you can start using it\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n</code></pre> <p>The next part of the code defines all of the different variables that will be used in the script:</p> <pre><code>--Define npc\nlocal Dummy = workspace.Dummy\n\n--Define a part called \"Goal\"\nlocal Goal = workspace.Goal\n\n--Create a new Path using the Dummy\nlocal Path = SimplePath.new(Dummy)\n</code></pre> <p>Note</p> <p><code>SimplePath.new()</code> is a constructor that creates a new Path and it should only be created once per agent. You can call <code>Path:Run()</code> on the same Path object multiple times without having to create a new Path every time you need to do pathfinding.</p>"},{"location":"guides/getting-started/#method-1-using-events","title":"Method 1: Using Events","text":"<p>The following part of the tutorial shows you how you can make a pathfinding script using only events. </p> <p>To make the Dummy move towards the goal, you only need one line of code: <pre><code>Path:Run(Goal)\n</code></pre></p> <p>Even though this single line of code seems sufficient, there are a few important things to keep in mind. Firstly, if some object comes in-between the path of the Dummy, the Dummy will just stop pathfinding before reaching the goal because <code>Path:Run()</code> is not called a second time to compute the path again. To fix this, you can use the <code>Path.Blocked</code> event and call <code>Path:Run()</code> whenever something blocks the path:</p> <pre><code>--Dummy knows to compute path again if something blocks the path\nPath.Blocked:Connect(function()\n    Path:Run(Goal)\nend)\n</code></pre> <p>The next thing to keep in mind is the position of the goal part. In the case where the goal part is constantly moving, how can you alter the current path of Dummy to make sure that it reaches the exact position of the goal part? You can do this by adding in 2 more events. </p> <p>The <code>Path.WaypointReached</code> event will compute a new Path everytime the Dummy reaches the next waypoint and accounts for a new position of the goal part if it changed.</p> <pre><code>--If the position of Goal changes at the next waypoint, compute path again\nPath.WaypointReached:Connect(function()\n    Path:Run(Goal)\nend)\n</code></pre> <p>The second event is <code>Path.Error</code>. You can compute a new path every time the target becomes unreachable or the path to the goal is not traversable. For example, if the part is floating in the sky, the Dummy would not be able to reach it and <code>Path.Error</code> fires.</p> <pre><code>--Dummmy knows to compute path again if an error occurs\nPath.Error:Connect(function(errorType)\n    Path:Run(Goal)\nend)\n</code></pre> <p>Your code should look something like this after adding everything in:</p> <pre><code>--Import the module so you can start using it\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\n--Define npc\nlocal Dummy = workspace.Dummy\n\n-- Define a part called \"Goal\"\nlocal Goal = workspace.Goal\n\n--Create a new Path using the Dummy\nlocal Path = SimplePath.new(Dummy)\n\n--Helps to visualize the path\nPath.Visualize = true\n\n--Dummy knows to compute path again if something blocks the path\nPath.Blocked:Connect(function()\n    Path:Run(Goal)\nend)\n\n--If the position of Goal changes at the next waypoint, compute path again\nPath.WaypointReached:Connect(function()\n    Path:Run(Goal)\nend)\n\n--Dummmy knows to compute path again if an error occurs\nPath.Error:Connect(function(errorType)\n    Path:Run(Goal)\nend)\n\nPath:Run(Goal)\n</code></pre> <p>Info</p> <p>Set <code>Path.Visualize</code> to <code>true</code> before the very first <code>Path:Run()</code> call to see the waypoints.</p> <p>As you can see, the Dummy stops pathfinding after reaching the goal. If you want the Dummy to always follow the goal part even after reaching it, you can simply use the <code>Path.Reached</code> event:</p> <pre><code>--Compute a new path every time the Dummy reaches the goal part\nPath.Reached:Connect(function()\n    Path:Run(Goal)\nend)\n</code></pre>"},{"location":"guides/getting-started/#method-2-using-loops","title":"Method 2: Using Loops","text":"<p>In the following tutorial, you will learn how to use SimplePath using loops instead of events.</p> <p>Using SimplePath in a loop is way simpler than using events. You only need 3 lines of code: <pre><code>while true do\n    Path:Run(Goal)\nend\n</code></pre></p> <p><code>Path:Run()</code> does not require a wait because it automatically yields if the maximum time elapsed between consecutive calls are less than <code>Settings.TIME_VARIANCE</code>.</p> <p>If you are using loops, your final code should look something like this:</p> <pre><code>--Import the module so you can start using it\nlocal ServerStorage = game:GetService(\"ServerStorage\")\nlocal SimplePath = require(ServerStorage.SimplePath)\n\n--Define npc\nlocal Dummy = workspace.Dummy\n\n-- Define a part called \"Goal\"\nlocal Goal = workspace.Goal\n\n--Create a new Path using the Dummy\nlocal Path = SimplePath.new(Dummy)\n\n--Helps to visualize the path\nPath.Visualize = true\n\nwhile true do\n    Path:Run(Goal)\nend\n</code></pre>"},{"location":"guides/getting-started/#choosing-the-right-method","title":"Choosing the right method","text":"<p>SimplePath gives you the freedom to code in any method you prefer. You are not limited to the two methods mentioned in this tutorial as they are simply meant to be examples. You can even combine both methods and implement them together at once. It all depends on how you decide to structure your code based on the performance, compatibility, etc. and personal preference.</p>"}]}